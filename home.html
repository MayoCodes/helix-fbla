<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helix - Your Pet Dashboard</title>
    <link rel="stylesheet" href="style_new.css">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    
    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; }
        .dashboard { min-height: 100vh; height: 100vh; background: #2C3E50; padding-top: 70px; }
        .dashboard-split { display: grid; grid-template-columns: 70% 30%; height: calc(100vh - 70px); }
        .scene-container { position: relative; background: linear-gradient(135deg, #1a252f 0%, #2C3E50 100%); overflow: hidden; }
        #renderCanvas { width: 100%; height: 100%; display: block; outline: none; }
        
        /* Stats Overlay - Wide Horizontal Design */
        .scene-info { 
            position: absolute; top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.8rem 1rem; 
            border-radius: 12px; 
            color: #2C3E50; 
            backdrop-filter: blur(30px) saturate(180%);
            z-index: 10; 
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
        }
        
        .stats-main-container {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            align-items: flex-start;
        }
        
        .pet-name-money {
            display: flex;
            gap: 0.8rem;
            align-items: center;
        }
        
        .scene-info h3 { 
            margin: 0;
            font-size: 0.95rem; 
            color: #2C3E50; 
            font-weight: 700;
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }
        
        .coins-display {
            background: #4A9B9B;
            padding: 0.3rem 0.7rem;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            box-shadow: 0 2px 6px rgba(255, 165, 0, 0.2);
        }
        
        .coins-icon-svg {
            width: 16px;
            height: 16px;
            color: rgba(255,255,255,0.95);
            stroke-width: 2.5;
        }
        
        .coins-display .coins-amount {
            font-size: 0.85rem;
            font-weight: 800;
            color: #ffffff;
            letter-spacing: 0.3px;
        }
        
        .mood-display {
            padding: 0.3rem 0.5rem;
            border-radius: 6px;
            background: rgba(0,0,0,0.05);
            border: 2px solid rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .mood-display.happy {
            background: rgba(255, 179, 71, 0.15);
            border-color: rgba(255, 179, 71, 0.3);
        }
        
        .mood-display.sad {
            background: rgba(107, 107, 255, 0.15);
            border-color: rgba(107, 107, 255, 0.3);
        }
        
        .mood-display.sick {
            background: rgba(255, 107, 107, 0.15);
            border-color: rgba(255, 107, 107, 0.3);
        }
        
        .mood-display.energetic {
            background: rgba(96, 165, 250, 0.15);
            border-color: rgba(96, 165, 250, 0.3);
        }
        
        .mood-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: currentColor;
        }
        
        .mood-icon svg {
            width: 100%;
            height: 100%;
        }
        
        .stats-overlay { 
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            flex: 1;
            width: 100%;
        }
        
        .level-bar-container {
            margin-bottom: 0.4rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(0,0,0,0.08);
        }
        
        .level-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
        }
        
        .level-label {
            font-size: 0.75rem;
            font-weight: 700;
            color: #4A9B9B;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .level-xp {
            font-size: 0.65rem;
            font-weight: 600;
            color: #5a6c7d;
        }
        
        .level-bar-wrapper {
            width: 100%;
            position: relative;
            height: 12px;
            background: rgba(74, 155, 155, 0.1);
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid rgba(74, 155, 155, 0.2);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .level-bar-fill {
            height: 100%;
            background: #4A9B9B;
            border-radius: 6px;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: absolute;
            top: 0;
            left: 0;
            box-shadow: 0 0 10px rgba(74, 155, 155, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }
        
        .stat-row {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }
        
        .stat-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .stat-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: #5a6c7d;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .stat-value {
            font-size: 0.7rem;
            font-weight: 700;
            color: #2C3E50;
        }
        
        .stat-icon-wrapper {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }
        
        .stat-icon-wrapper.health {
            background: #4A9B9B;
        }
        
        .stat-icon-wrapper.happiness {
            background: #4A9B9B;
        }
        
        .stat-icon-wrapper.hunger {
            background: #4A9B9B;
        }
        
        .stat-icon-wrapper.energy {
            background: #4A9B9B;
        }
        
        .stat-icon-svg {
            width: 16px;
            height: 16px;
            color: white;
            stroke-width: 2.5;
        }
        
        .stat-bar-wrapper {
            width: 100%;
            position: relative;
            height: 8px;
            background: rgba(0,0,0,0.08);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .stat-bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .total-spent-container {
            padding-top: 0.4rem;
            margin-top: 0.3rem;
            border-top: 1px solid rgba(0,0,0,0.08);
        }
        
        .total-spent {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.6rem;
            color: #7a8a9a;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        
        .total-spent .amount {
            color: #4A9B9B;
            font-weight: 700;
            font-size: 0.85rem;
        }
        
        /* Responsive */
        @media (max-width: 1000px) {
            .scene-info {
                min-width: auto;
                width: 95%;
                padding: 1.2rem 1.5rem;
            }
            .stats-main-container {
                flex-direction: column;
                gap: 1.5rem;
            }
            .stats-overlay {
                grid-template-columns: repeat(2, 1fr);
                width: 100%;
            }
        }
        
        /* Bright, vibrant colors for stats */
        .stat-bar-fill.health { 
            background: #4A9B9B; 
        }
        .stat-bar-fill.happiness { 
            background: #4A9B9B; 
        }
        .stat-bar-fill.hunger { 
            background: #4A9B9B; 
        }
        .stat-bar-fill.energy { 
            background: #4A9B9B; 
        }
        
        /* Control Panel */
        .control-panel { background: #FFFFFF; display: flex; flex-direction: column; overflow-y: auto; }
        .control-header { padding: 1.5rem; border-bottom: 2px solid #e0e0e0; background: #F8F9FA; }
        .control-header h2 { margin: 0 0 0.5rem 0; color: #2C3E50; font-size: 1.6rem; }
        .control-header p { margin: 0; color: #666; font-size: 0.9rem; }
        
        /* Model Selector */
        .model-selector { margin-top: 1rem; }
        .model-selector label { display: block; margin-bottom: 0.5rem; color: #2C3E50; font-weight: 600; font-size: 0.9rem; }
        
        .mini-pet-bubbles {
            display: flex;
            gap: 0.8rem;
            padding: 0.5rem 0;
            flex-wrap: wrap;
        }
        
        .mini-bubble {
            width: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.4rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .mini-bubble-canvas {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid #e0e0e0;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            display: block;
        }
        
        .mini-bubble:hover .mini-bubble-canvas {
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .mini-bubble.selected .mini-bubble-canvas {
            border-color: #4A9B9B;
            box-shadow: 0 4px 16px rgba(74, 155, 155, 0.4);
            background: rgba(74, 155, 155, 0.1);
        }
        
        .mini-bubble-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #2C3E50;
            text-align: center;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .mini-bubble.selected .mini-bubble-label {
            color: #4A9B9B;
        }
        
        /* Care Actions Section */
        .care-section { padding: 1.5rem; border-bottom: 2px solid #e0e0e0; }
        
        /* Expense Tracker */
        .expense-tracker {
            background: #f0fdfa;
            border: 2px solid #4A9B9B;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .expense-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }
        
        .expense-label {
            color: #374151;
            font-weight: 500;
        }
        
        .expense-value {
            font-weight: 700;
            color: #4A9B9B;
        }
        
        .expense-value.remaining {
            font-size: 1.1rem;
        }
        
        .expense-value.low {
            color: #dc2626;
        }
        
        .expense-bar {
            height: 10px;
            background: #e5e7eb;
            border-radius: 5px;
            overflow: hidden;
            margin: 0.75rem 0;
        }
        
        .expense-bar-fill {
            height: 100%;
            background: #4A9B9B;
            transition: width 0.3s ease;
        }
        
        .expense-bar-fill.low {
            background: #dc2626;
        }
        
        .expense-breakdown {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #cbd5e1;
        }
        
        .expense-category {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #6b7280;
            margin-bottom: 0.25rem;
        }

        .care-section h3 { margin: 0 0 1rem 0; color: #2C3E50; font-size: 1.2rem; }
        
        /* Traits Section */
        .traits-section { padding: 1.5rem; border-bottom: 2px solid #e0e0e0; }
        

        .traits-section h3 { margin: 0 0 1rem 0; color: #2C3E50; font-size: 1.2rem; }
        
        .age-display {
            background: #4A9B9B;
            color: white;
            padding: 0.6rem 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .age-label {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            opacity: 0.9;
        }
        
        .age-value {
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .trait-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .trait-tag {
            background: #4A9B9B;
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .bond-display {
            margin-top: 1rem;
        }
        
        .bond-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .bond-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #5a6c7d;
            text-transform: uppercase;
        }
        
        .bond-value {
            font-size: 0.8rem;
            font-weight: 700;
            color: #2C3E50;
        }
        
        .bond-bar-wrapper {
            width: 100%;
            height: 8px;
            background: rgba(255, 107, 153, 0.15);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 107, 153, 0.2);
        }
        
        .bond-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF6B99, #FF9DBB);
            border-radius: 8px;
            transition: width 0.6s ease;
        }
        
        .bond-milestone {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #666;
            font-style: italic;
            text-align: center;
        }
        
        /* Tasks Section */
        .tasks-section { padding: 1.5rem; border-bottom: 2px solid #e0e0e0; background: linear-gradient(to bottom, #ffffff, #f8f9fa); }
        .tasks-section h3 { margin: 0 0 0.5rem 0; color: #2C3E50; font-size: 1.2rem; }
        
        .ai-button {
            background: #4A9B9B;
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .ai-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .ai-button svg {
            width: 14px;
            height: 14px;
        }
        
        /* Chat Section */
        .chat-section {
            padding: 1.5rem;
            border-bottom: 2px solid #e0e0e0;
            background: #f8f9fa;
        }
        
        .chat-section h3 {
            margin: 0 0 1rem 0;
            color: #2C3E50;
            font-size: 1.2rem;
        }
        
        .chat-messages {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }
        
        .chat-message {
            padding: 0.8rem;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
        }
        
        .chat-message.user {
            background: #4A9B9B;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }
        
        .chat-message.pet {
            background: white;
            color: #2C3E50;
            border: 2px solid #e0e0e0;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }
        
        .chat-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        
        .chat-option-btn {
            background: #F8F9FA;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.6rem;
            font-size: 0.9rem;
            font-weight: 600;
            color: #2C3E50;
        }
        
        .chat-option-btn:hover {
            background: #4A9B9B;
            border-color: #4A9B9B;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 155, 155, 0.3);
        }
        
        .chat-option-btn svg {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        
        .chat-option-btn:hover svg {
            color: white;
        }
        
        /* Events Section */
        .events-section {
            padding: 1.5rem;
            border-bottom: 2px solid #e0e0e0;
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
        }
        
        .events-section h3 {
            margin: 0 0 1rem 0;
            color: #2C3E50;
            font-size: 1.2rem;
        }
        
        .event-card {
            background: white;
            padding: 1rem;
            border-radius: 12px;
            border: 2px solid #fdcb6e;
        }
        
        .event-title {
            font-weight: 700;
            color: #2C3E50;
            margin-bottom: 0.5rem;
        }
        
        .event-dialogue {
            font-style: italic;
            color: #5a6c7d;
        }
        
        .tasks-subtitle {
            margin: 0 0 1rem 0;
            font-size: 0.8rem;
            color: #666;
            font-style: italic;
        }
        
        .task-list {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }
        
        .task-item {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .task-item:hover {
            background: #4A9B9B;
            border-color: #4A9B9B;
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(74, 155, 155, 0.4);
        }
        
        .task-item:hover .task-name,
        .task-item:hover .task-duration {
            color: white;
        }
        
        .task-item:hover .task-icon {
            color: white;
        }
        
        .task-item.completed {
            opacity: 0.7;
            cursor: not-allowed;
            background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
            border-color: #4CAF50;
        }
        
        .task-item.completed:hover {
            transform: none;
            background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .task-header {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
        }
        
        .task-icon {
            width: 28px;
            height: 28px;
            color: #4A9B9B;
            transition: transform 0.3s ease;
            flex-shrink: 0;
        }
        
        .task-icon svg {
            width: 100%;
            height: 100%;
        }
        
        .task-item:hover .task-icon {
            color: white;
        }
        
        .inline-icon {
            width: 14px;
            height: 14px;
            display: inline-block;
            vertical-align: middle;
            margin-right: 0.2rem;
        }
        
        .task-name {
            font-weight: 600;
            color: #2C3E50;
            font-size: 0.95rem;
            flex: 1;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .task-duration {
            font-size: 0.75rem;
            color: #666;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            margin-left: 36px;
        }
        
        .task-reward {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 36px;
            flex-wrap: wrap;
        }
        
        .task-coins {
            color: #FFB347;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            white-space: nowrap;
        }
        
        .task-bond {
            color: #FF6B99;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            white-space: nowrap;
        }
        
        .task-checkmark {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 24px;
            height: 24px;
            color: #4CAF50;
        }
        
        .task-checkmark svg {
            width: 100%;
            height: 100%;
        }
        
        /* Circular Timer */
        .task-timer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
        }
        
        .task-item.in-progress {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            border-color: #4A9B9B;
            pointer-events: none;
        }
        
        .timer-svg {
            transform: rotate(-90deg);
        }
        
        .timer-circle-bg {
            fill: none;
            stroke: #e0e0e0;
            stroke-width: 8;
        }
        
        .timer-circle-progress {
            fill: none;
            stroke: #4A9B9B;
            stroke-width: 8;
            stroke-linecap: round;
            transition: stroke-dashoffset 1s linear;
        }
        
        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            font-weight: 700;
            color: #4A9B9B;
        }
        .care-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 0.8rem; }
        
        .care-btn {
            background: #F8F9FA; border: 2px solid #e0e0e0; border-radius: 10px;
            padding: 1rem; cursor: pointer; transition: all 0.3s ease;
            display: flex; flex-direction: column; align-items: center; gap: 0.4rem;
            position: relative;
        }
        .care-btn:hover { background: #4A9B9B; border-color: #4A9B9B; transform: translateY(-2px); }
        .care-btn:hover .btn-icon { transform: scale(1.1); }
        .care-btn:hover .btn-label { color: #FFFFFF; }
        .care-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .care-btn:disabled:hover { background: #F8F9FA; border-color: #e0e0e0; transform: none; }
        
        .btn-icon { 
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease; 
        }
        .btn-icon svg {
            width: 100%;
            height: 100%;
        }
        .btn-label { font-weight: 600; color: #2C3E50; font-size: 0.85rem; transition: color 0.3s ease; text-align: center; }
        .btn-cost { font-size: 0.75rem; color: #666; margin-top: 0.2rem; }
        .care-btn:hover .btn-cost { color: rgba(255,255,255,0.9); }
        
        /* Floating Add Pet Button */
        .add-pet-btn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 60px;
            height: 60px;
            background: #4A9B9B;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(74, 155, 155, 0.4);
            transition: all 0.3s;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .add-pet-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(74, 155, 155, 0.6);
            background: #3a8a8a;
        }
        
        .add-pet-btn svg {
            width: 30px;
            height: 30px;
        }
        
        .btn-secondary { 
            width: 100%; padding: 1rem; background: transparent; 
            border: 2px solid #2C3E50; border-radius: 8px; color: #2C3E50; 
            font-weight: 600; cursor: pointer; transition: all 0.3s ease; 
        }
        .btn-secondary:hover { background: #2C3E50; color: #FFFFFF; }
        
        /* Modal for Pet Setup */
        /* Custom Alert */
        .custom-alert {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .custom-alert.active {
            display: flex;
        }
        
        .custom-alert-content {
            background: white;
            border: 3px solid #4A9B9B;
            border-radius: 12px;
            padding: 2rem;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 8px 24px rgba(74, 155, 155, 0.3);
            animation: alertSlideIn 0.3s ease;
        }
        
        @keyframes alertSlideIn {
            from {
                transform: scale(0.8) translateY(-20px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        .custom-alert-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .custom-alert-message {
            font-size: 1.1rem;
            color: #2C3E50;
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }
        
        .custom-alert-btn {
            background: #4A9B9B;
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .custom-alert-btn:hover {
            background: #3a8a8a;
            transform: translateY(-2px);
        }

        .modal { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: white;
            z-index: 1000; 
            overflow-y: auto;
        }
        .modal.active { display: block; }
        
        .setup-screen {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            background: white;
        }
        
        .setup-title {
            font-size: 3rem;
            color: #4A9B9B;
            margin: 0 0 3rem 0;
            font-weight: 700;
            text-align: center;
        }
        
        .pet-carousel {
            display: flex;
            align-items: center;
            gap: 2rem;
            margin-bottom: 3rem;
            width: 100%;
            max-width: 1200px;
        }
        
        .carousel-arrow {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #f0f0f0;
            border: none;
            font-size: 2.5rem;
            color: #666;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        .carousel-arrow:hover {
            background: #4A9B9B;
            color: white;
            transform: scale(1.1);
        }
        
        .pet-bubbles-container {
            display: flex;
            gap: 2rem;
            overflow-x: auto;
            scroll-behavior: smooth;
            padding: 1rem;
            flex: 1;
            justify-content: center;
        }
        
        .pet-bubbles-container::-webkit-scrollbar {
            height: 8px;
        }
        .pet-bubbles-container::-webkit-scrollbar-thumb {
            background: #4A9B9B;
            border-radius: 4px;
        }
        
        .pet-bubble {
            min-width: 300px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        
        .pet-bubble:hover {
            transform: translateY(-10px);
        }
        
        .bubble-canvas-wrapper {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: white;
            border: 5px solid #e0e0e0;
            overflow: hidden;
            position: relative;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .pet-bubble.selected .bubble-canvas-wrapper {
            background: #4A9B9B;
            border-color: #4A9B9B;
            box-shadow: 0 20px 50px rgba(74, 155, 155, 0.4);
            transform: scale(1.05);
        }
        
        .bubble-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .bubble-label {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2C3E50;
            margin: 0;
            transition: color 0.3s ease;
        }
        
        .pet-bubble.selected .bubble-label {
            color: #4A9B9B;
        }
        
        .name-input-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 100%;
            max-width: 500px;
        }
        
        .name-input-section input {
            width: 100%;
            padding: 1.2rem 1.5rem;
            font-size: 1.3rem;
            border: 3px solid #e0e0e0;
            border-radius: 50px;
            text-align: center;
            transition: all 0.3s ease;
            outline: none;
        }
        
        .name-input-section input:focus {
            border-color: #4A9B9B;
            box-shadow: 0 0 0 4px rgba(74, 155, 155, 0.1);
        }
        
        .start-btn {
            width: 100%;
            padding: 1.2rem 2rem;
            font-size: 1.3rem;
            font-weight: 700;
            background: #4A9B9B;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(74, 155, 155, 0.3);
        }
        
        .start-btn:hover {
            background: #3d8585;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(74, 155, 155, 0.4);
        }
        
        .start-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }
    </style>
</head>
<body>
    <nav id="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo"><span class="logo-text">HELIX</span></a>
            <div class="nav-auth-buttons">
                <button class="btn-nav btn-logout" onclick="handleLogout()">Logout</button>
            </div>
        </div>
    </nav>

    <section class="dashboard">
        <div class="dashboard-split">
            <!-- 3D Viewer -->
            <div class="scene-container">
                <canvas id="renderCanvas"></canvas>
                <div class="scene-info">
                    <div class="stats-main-container">
                        <div class="pet-name-money">
                            <h3 id="petNameDisplay">Loading...</h3>
                            <div class="coins-display">
                                <svg class="coins-icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="8" r="7"></circle>
                                    <circle cx="12" cy="16" r="7" opacity="0.5"></circle>
                                </svg>
                                <div class="coins-amount"><span id="coinsStat">100</span> coins</div>
                            </div>
                            <div class="mood-display" id="moodDisplay" title="Current mood">
                                <span class="mood-icon">ðŸ˜Š</span>
                            </div>
                        </div>
                        
                        <div class="level-bar-container">
                            <div class="level-info">
                                <span class="level-label">Level <span id="levelNum">1</span></span>
                                <span class="level-xp"><span id="currentXP">0</span>/<span id="maxXP">100</span> XP</span>
                            </div>
                            <div class="level-bar-wrapper">
                                <div class="level-bar-fill" id="levelBar" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="stats-overlay">
                            <div class="stat-row">
                                <div class="stat-icon-wrapper health">
                                    <svg class="stat-icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                                    </svg>
                                </div>
                                <div class="stat-info">
                                    <div class="stat-header-row">
                                        <span class="stat-label" title="Higher is better">Health</span>
                                        <span class="stat-value"><span id="healthStat">100</span>%</span>
                                    </div>
                                    <div class="stat-bar-wrapper">
                                        <div class="stat-bar-fill health" id="healthBar" style="width: 100%"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="stat-row">
                                <div class="stat-icon-wrapper happiness">
                                    <svg class="stat-icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                                        <line x1="9" y1="9" x2="9.01" y2="9"></line>
                                        <line x1="15" y1="9" x2="15.01" y2="9"></line>
                                    </svg>
                                </div>
                                <div class="stat-info">
                                    <div class="stat-header-row">
                                        <span class="stat-label" title="Higher is better">Happiness</span>
                                        <span class="stat-value"><span id="happinessStat">100</span>%</span>
                                    </div>
                                    <div class="stat-bar-wrapper">
                                        <div class="stat-bar-fill happiness" id="happinessBar" style="width: 100%"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="stat-row">
                                <div class="stat-icon-wrapper hunger">
                                    <svg class="stat-icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M18 8h1a4 4 0 0 1 0 8h-1M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path>
                                        <line x1="6" y1="1" x2="6" y2="4"></line>
                                        <line x1="10" y1="1" x2="10" y2="4"></line>
                                        <line x1="14" y1="1" x2="14" y2="4"></line>
                                    </svg>
                                </div>
                                <div class="stat-info">
                                    <div class="stat-header-row">
                                        <span class="stat-label" title="Higher is better">Fullness</span>
                                        <span class="stat-value"><span id="fullnessStat">100</span>%</span>
                                    </div>
                                    <div class="stat-bar-wrapper">
                                        <div class="stat-bar-fill hunger" id="fullnessBar" style="width: 100%"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="stat-row">
                                <div class="stat-icon-wrapper energy">
                                    <svg class="stat-icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                                    </svg>
                                </div>
                                <div class="stat-info">
                                    <div class="stat-header-row">
                                        <span class="stat-label" title="Higher is better - Rest to restore">Energy</span>
                                        <span class="stat-value"><span id="energyStat">100</span>%</span>
                                    </div>
                                    <div class="stat-bar-wrapper">
                                        <div class="stat-bar-fill energy" id="energyBar" style="width: 100%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="total-spent-container">
                        <div class="total-spent">
                            <span>TOTAL EXPENSES</span>
                            <span class="amount">$<span id="totalSpent">0</span></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Control Panel -->
            <div class="control-panel">
                <div class="control-header">
                    <h2>Pet Care</h2>
                    <p id="userGreeting">Loading...</p>
                    
                    <div class="model-selector">
                        <label>Your Pets:</label>
                        <div class="mini-pet-bubbles" id="miniPetBubblesContainer">
                            <!-- Dynamically populated from userPets -->
                        </div>
                    </div>
                </div>
                
                <!-- Pet Traits & Info -->
                <div class="traits-section">
                    <h3>Pet Info</h3>
                    <div class="age-display">
                        <span class="age-label">Age:</span>
                        <span class="age-value" id="ageValue">Baby</span>
                    </div>
                    <div class="trait-tags" id="traitTags">
                        <!-- Dynamically populated -->
                    </div>
                    <div class="bond-display">
                        <div class="bond-header">
                            <span class="bond-label">Bond Level</span>
                            <span class="bond-value"><span id="bondValue">0</span>/100</span>
                        </div>
                        <div class="bond-bar-wrapper">
                            <div class="bond-bar-fill" id="bondBar" style="width: 0%"></div>
                        </div>
                        <div class="bond-milestone" id="bondMilestone"></div>
                    </div>
                </div>
                
                <!-- Daily Tasks -->
                <div class="tasks-section">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <h3 style="margin: 0;">Daily Tasks</h3>
                        <button class="ai-button" onclick="refreshAITasks()" title="Generate AI tasks">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"></path>
                            </svg>
                            AI Tasks
                        </button>
                    </div>
                    <p class="tasks-subtitle">Complete tasks to earn coins and increase bond!</p>
                    <div class="task-list" id="taskList">
                        <!-- Dynamically populated based on pet type -->
                    </div>
                </div>
                
                <!-- AI Pet Chat -->
                <div class="chat-section">
                    <h3>Talk to Your Pet</h3>
                    <div class="chat-messages" id="chatMessages"></div>
                    <div class="chat-options">
                        <button class="chat-option-btn" onclick="sendPremadeMessage('How are you feeling today?')">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                                <line x1="9" y1="9" x2="9.01" y2="9"></line>
                                <line x1="15" y1="9" x2="15.01" y2="9"></line>
                            </svg>
                            How are you?
                        </button>
                        <button class="chat-option-btn" onclick="sendPremadeMessage('Youre such a good pet!')">>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                            </svg>
                            Good pet!
                        </button>
                        <button class="chat-option-btn" onclick="sendPremadeMessage('Do you need anything?')">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                                <line x1="12" y1="17" x2="12.01" y2="17"></line>
                            </svg>
                            Need anything?
                        </button>
                        <button class="chat-option-btn" onclick="sendPremadeMessage('Tell me a story!')">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                                <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                            </svg>
                            Tell story
                        </button>
                    </div>
                </div>
                
                <!-- Random Events -->
                <div class="events-section" id="eventsSection" style="display: none;">
                    <h3>Something Happened!</h3>
                    <div class="event-card" id="eventCard"></div>
                </div>
                
                <!-- Care Actions -->
                <div class="care-section">
                    <h3>Care Actions</h3>
                    
                    <!-- Cost Tracking Display -->
                    <div class="expense-tracker">
                        <div class="expense-row">
                            <span class="expense-label">Monthly Budget:</span>
                            <span class="expense-value">$<span id="monthlyBudget">200</span></span>
                        </div>
                        <div class="expense-row">
                            <span class="expense-label">Remaining:</span>
                            <span class="expense-value remaining" id="budgetRemaining">$200</span>
                        </div>
                        <div class="expense-bar">
                            <div class="expense-bar-fill" id="budgetBar" style="width: 100%"></div>
                        </div>
                        <div class="expense-breakdown">
                            <div class="expense-category">
                                <span>Food/Supplies:</span>
                                <span>$<span id="foodSpent">0</span></span>
                            </div>
                            <div class="expense-category">
                                <span>Health Care:</span>
                                <span>$<span id="vetSpent">0</span></span>
                            </div>
                            <div class="expense-category">
                                <span>Toys/Activities:</span>
                                <span>$<span id="toySpent">0</span></span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="care-buttons">
                        <button class="care-btn" onclick="feedPet()">
                            <span class="btn-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M18 8h1a4 4 0 0 1 0 8h-1M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path>
                                    <line x1="6" y1="1" x2="6" y2="4"></line>
                                    <line x1="10" y1="1" x2="10" y2="4"></line>
                                    <line x1="14" y1="1" x2="14" y2="4"></line>
                                </svg>
                            </span>
                            <span class="btn-label">Feed</span>
                            <span class="btn-cost">$10</span>
                        </button>
                        <button class="care-btn" onclick="playWithPet()">
                            <span class="btn-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <path d="M8 15h8M9 9h.01M15 9h.01"></path>
                                </svg>
                            </span>
                            <span class="btn-label">Play (Toy)</span>
                            <span class="btn-cost">$15</span>
                        </button>
                        <button class="care-btn" onclick="restPet()">
                            <span class="btn-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M2 12h20M2 12l8-8m-8 8l8 8"></path>
                                </svg>
                            </span>
                            <span class="btn-label">Rest</span>
                            <span class="btn-cost">Free</span>
                        </button>
                        <button class="care-btn" onclick="healthCheck()">
                            <span class="btn-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M22 12h-4l-3 9L9 3l-3 9H2"></path>
                                </svg>
                            </span>
                            <span class="btn-label">Health Check (Vet)</span>
                            <span class="btn-cost">$50</span>
                        </button>
                    </div>
                </div>
                
                
                <div class="control-footer">
                    <button class="btn-secondary" onclick="window.location.href='index.html'">Back to Home</button>
                </div>
            </div>
        </div>
        
        <!-- Add Pet Button (floating) -->
        <button class="add-pet-btn" onclick="showSetupModal()" title="Add New Pet">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        </button>
    </section>

    <!-- Custom Alert Modal -->
    <div class="custom-alert" id="customAlert">
        <div class="custom-alert-content">
            <div class="custom-alert-icon" id="alertIcon">â„¹ï¸</div>
            <div class="custom-alert-message" id="alertMessage"></div>
            <button class="custom-alert-btn" onclick="closeCustomAlert()">OK</button>
        </div>
    </div>

    <!-- Pet Setup Modal -->
    <div class="modal" id="setupModal">
        <div class="setup-screen">
            <h1 class="setup-title">Choose Your New Pet!</h1>
            
            <div class="pet-carousel">
                <button class="carousel-arrow left" onclick="scrollPets(-1)">â€¹</button>
                
                <div class="pet-bubbles-container" id="petBubblesContainer">
                    <div class="pet-bubble" data-type="a" onclick="selectPetBubble('a')">
                        <div class="bubble-canvas-wrapper">
                            <canvas class="bubble-canvas" id="bubbleCanvas_a"></canvas>
                        </div>
                        <p class="bubble-label">Cat</p>
                    </div>
                    
                    <div class="pet-bubble" data-type="b" onclick="selectPetBubble('b')">
                        <div class="bubble-canvas-wrapper">
                            <canvas class="bubble-canvas" id="bubbleCanvas_b"></canvas>
                        </div>
                        <p class="bubble-label">Dog</p>
                    </div>
                    
                    <div class="pet-bubble" data-type="c" onclick="selectPetBubble('c')">
                        <div class="bubble-canvas-wrapper">
                            <canvas class="bubble-canvas" id="bubbleCanvas_c"></canvas>
                        </div>
                        <p class="bubble-label">Bird</p>
                    </div>
                </div>
                
                <button class="carousel-arrow right" onclick="scrollPets(1)">â€º</button>
            </div>
            
            <div class="name-input-section">
                <input type="text" id="petNameInput" placeholder="Enter your pet's name..." maxlength="20">
                <button class="start-btn" onclick="savePetSetup()">Start Your Journey</button>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration - REPLACE WITH YOUR ACTUAL FIREBASE CONFIG
        // Get this from: https://console.firebase.google.com -> Project Settings -> Your apps -> Web app
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY_HERE",
            authDomain: "YOUR_PROJECT.firebaseapp.com",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_PROJECT.appspot.com",
            messagingSenderId: "YOUR_SENDER_ID",
            appId: "YOUR_APP_ID"
        };
        
        // Check if Firebase is configured
        const isFirebaseConfigured = firebaseConfig.apiKey !== "YOUR_API_KEY_HERE" 
            && firebaseConfig.projectId !== "YOUR_PROJECT_ID";
        let db, auth, currentUser;
        
        if (isFirebaseConfigured) {
            try {
                firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
                console.log("âœ… Firebase initialized successfully");
                console.log("ðŸ” Firestore ONLY mode - all data stored in cloud");
                console.log("Project:", firebaseConfig.projectId);
            } catch (error) {
                console.error("âŒ Firebase initialization error:", error);
                showAlert("Firebase config error: " + error.message);
            }
        } else {
            console.error("âŒ Firebase NOT configured!");
            console.error("This app REQUIRES Firestore. Please configure Firebase:");
            console.error("1. Go to Firebase Console: https://console.firebase.google.com");
            console.error("2. Create/select your project");
            console.error("3. Enable Firestore Database");
            console.error("4. Go to Project Settings -> General -> Your apps -> Web app");
            console.error("5. Copy the firebaseConfig object");
            console.error("6. Paste it in home.html (lines 1329-1336)");
            showAlert("Firebase is required! Please configure Firebase to use this app. See console for instructions.");
        }

        // USER DATA - shared across all pets
        let userData = {
            coins: 500, // Shared currency
            costTracking: {
                totalSpent: 0,
                foodSpent: 0,
                vetSpent: 0,
                toySpent: 0,
                monthlyBudget: 200,
                budgetRemaining: 200,
                transactions: [],
                lastMonthReset: Date.now()
            }
        };

        // Pet Data Structure - now supports multiple pets
        let currentPetId = null; // ID of currently active pet
        let petData = {
            name: "Your Pet",
            type: "a", // a, b, c
            age: "baby", // baby, young, adult, senior
            level: 1,
            experience: 0,
            experienceToNextLevel: 100,
            health: 100,
            happiness: 100,
            fullness: 100, // Fullness (0 = starving, 100 = full)
            energy: 100,
            bond: 0, // Bond level with pet (0-100)
            
            treats: {}, // Pet-specific treats inventory
            tasksCompleted: {}, // Track completed tasks
            aiTasks: [], // AI-generated tasks for this pet
            lastTaskReset: Date.now(),
            lastUpdated: Date.now()
        };
        
        let userPets = {}; // Object storing all user's pets by ID
        
        // ============================================
        // GROQ AI CONFIGURATION  
        // ============================================
        
        const GROQ_API_KEY = "YOUR_GROQ_API_KEY_HERE"; // Not needed - using Vercel function
        const GROQ_FUNCTION_URL = "/api/groq"; // Vercel serverless function
        
        // Check if AI is enabled (always true on Vercel if env variable is set)
        function isAIEnabled() {
            return true; // Function will handle the key check
        }
        
        // AI Personality system
        async function callGroqAPI(prompt) {
            try {
                const requestBody = {
                    model: "llama-3.3-70b-versatile", // Fast and smart model
                    messages: [{
                        role: "user",
                        content: prompt
                    }],
                    temperature: 0.7,
                    max_tokens: 150
                };
                
                // Call Vercel serverless function
                const response = await fetch(GROQ_FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("Groq API error:", response.status, errorText);
                    return null;
                }
                
                const data = await response.json();
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    return data.choices[0].message.content;
                }
                return null;
            } catch (error) {
                console.error("Groq API Error:", error);
                return null;
            }
        }
        
        function getPetPersonalityContext() {
            const traits = PET_TRAITS[petData.type];
            const age = AGE_STAGES[petData.age || 'baby'];
            const daysSinceAdoption = Math.floor((Date.now() - (petData.adoptionDate || Date.now())) / (1000 * 60 * 60 * 24));
            
            return `You are ${petData.name}, a ${age.label.toLowerCase()} ${traits.name.toLowerCase()}.
Your personality traits: ${traits.traits.join(', ')}.
Your current stats: Health ${petData.health}%, Happiness ${petData.happiness}%, Fullness ${petData.fullness}%, Energy ${petData.energy}%.
Bond level with owner: ${petData.bond}/100.
Days since adoption: ${daysSinceAdoption}.

IMPORTANT: To increase bond, your owner must complete daily tasks with you (like playing, running, training). There is no direct "pet" action - bond grows through completing tasks together. If the user asks to pet you or increase bond, remind them to do daily tasks.

You should respond in first person as the pet. Be emotional and reference your stats. If stats are low, express sadness or concern. If stats are high, be happy and affectionate. Keep responses under 50 words and conversational.`;
        }
        
        async function generateAIDailyTasks() {
            const traits = PET_TRAITS[petData.type];
            const context = getPetPersonalityContext();
            
            // Get base task types for this pet
            const baseTaskNames = traits.tasks.map(t => t.name).join(', ');
            
            const prompt = `${context}

Based on your personality and typical ${traits.name} activities (${baseTaskNames}), generate 3 unique daily tasks for today.

TASK GENERATION RULES:
1. Base tasks on the default ${traits.name} activities but make them unique and personalized
2. Consider your current state:
   - If hungry (fullness < 40): Include food-related bonding activity
   - If low energy (< 30): Include calm/gentle activity
   - If sad (happiness < 50): Include extra fun/playful activity
   - Otherwise: Mix of physical and mental activities

Examples for ${traits.name}:
${traits.name === 'Dog' ? '- "Go to the dog park and make friends" (20 min)\n- "Learn a new trick: spin around" (10 min)\n- "Sniff walk around the neighborhood" (25 min)' : ''}
${traits.name === 'Cat' ? '- "Hunt the laser pointer" (10 min)\n- "Explore the closet for cozy spots" (15 min)\n- "Watch birds from the window together" (20 min)' : ''}
${traits.name === 'Bird' ? '- "Practice whistling a new song" (15 min)\n- "Explore outside the cage safely" (20 min)\n- "Learn colors with colorful toys" (10 min)' : ''}

Return ONLY a JSON array in this exact format (no markdown, no extra text):
[
  {"name": "task name", "duration": "X min", "coins": number, "bond": number},
  {"name": "task name", "duration": "X min", "coins": number, "bond": number},
  {"name": "task name", "duration": "X min", "coins": number, "bond": number}
]

IMPORTANT: 
- Duration: 5-10 min for quick tasks, 15-20 min for moderate, 30+ min for long activities
- Coins: 5-15 based on difficulty
- Bond: 10-30 based on engagement
- Make tasks feel personal and unique to ME, not generic`;

            const response = await callGroqAPI(prompt);
            
            if (response) {
                try {
                    // Clean up response - remove markdown code blocks if present
                    let cleanResponse = response.trim();
                    if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '');
                    }
                    
                    const tasks = JSON.parse(cleanResponse);
                    
                    // Add unique IDs
                    return tasks.map((task, index) => ({
                        id: `ai_task_${index}`,
                        ...task
                    }));
                } catch (e) {
                    console.error("Failed to parse AI tasks:", e);
                    return null;
                }
            }
            return null;
        }
        
        async function generateRandomEvent() {
            const context = getPetPersonalityContext();
            const daysSinceAdoption = Math.floor((Date.now() - (petData.adoptionDate || Date.now())) / (1000 * 60 * 60 * 24));
            
            // Determine event type based on care history
            let eventType = '';
            if (daysSinceAdoption >= 30) {
                eventType = 'Generate a heartfelt MEMORY about your time together. Reflect on how your owner has cared for you over the past month.';
            } else if (petData.happiness > 80 && petData.health > 80) {
                eventType = 'Generate a HAPPY event - you discovered something fun or met a friendly neighbor.';
            } else if (petData.fullness < 40) {
                eventType = 'Generate a FOOD-related event - you saw something delicious or smelled food.';
            } else if (petData.happiness < 50) {
                eventType = 'Generate a LONELINESS event - you miss your owner or want attention.';
            } else {
                eventType = 'Generate a QUIRKY/FUNNY event - something amusing happened today.';
            }
            
            const prompt = `${context}

Days since adoption: ${daysSinceAdoption}

${eventType}

Examples of events:
- "Your cat befriended a neighborhood bird and wants you to buy bird treats"
- "Found a cozy sunspot by the window and took the best nap ever!"  
- "Saw a squirrel outside and it looked so tasty..."
- "Remember when you first adopted me? I was scared, but you took such good care of me!"
- "I heard thunder today and got scared. Can we cuddle?"

Return ONLY a JSON object in this exact format (no markdown, no extra text):
{"event": "brief description of what happened", "dialogue": "what you say to your owner about it (under 50 words, emotional and personal, use first person)"}`;

            const response = await callGroqAPI(prompt);
            
            if (response) {
                try {
                    let cleanResponse = response.trim();
                    if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '');
                    }
                    return JSON.parse(cleanResponse);
                } catch (e) {
                    console.error("Failed to parse event:", e);
                    return null;
                }
            }
            return null;
        }
        
        async function chatWithPet(userMessage) {
            const context = getPetPersonalityContext();
            
            const prompt = `${context}

Your owner just said to you: "${userMessage}"

Respond as the pet in first person. Be emotional and reference your current state. If you're unhappy, explain why. If you're happy, show affection. Keep it under 50 words.`;

            return await callGroqAPI(prompt);
        }
        
        // Age stages based on bond level
        const AGE_STAGES = {
            baby: { minBond: 0, maxBond: 24, label: "Baby", scale: 0.8 },
            young: { minBond: 25, maxBond: 49, label: "Young", scale: 1.0 },
            adult: { minBond: 50, maxBond: 74, label: "Adult", scale: 1.2 },
            senior: { minBond: 75, maxBond: 100, label: "Senior", scale: 1.1 }
        };
        
        // Pet Traits and Tasks System
        const PET_TRAITS = {
            a: { // Cat
                name: "Cat",
                traits: ["Independent", "Playful", "Curious"],
                tasks: [
                    { id: "playtime", name: "Play with toys", coins: 5, bond: 10, duration: "5 min" },
                    { id: "socialize", name: "Pet and cuddle", coins: 8, bond: 15, duration: "10 min" },
                    { id: "explore", name: "Let explore around house", coins: 10, bond: 20, duration: "15 min" }
                ],
                treatName: "Cat Treats",
                treatCost: 10
            },
            b: { // Dog
                name: "Dog",
                traits: ["Loyal", "Energetic", "Social"],
                tasks: [
                    { id: "run", name: "Go for a run", coins: 10, bond: 20, duration: "20 min" },
                    { id: "fetch", name: "Play fetch", coins: 8, bond: 15, duration: "15 min" },
                    { id: "train", name: "Practice commands", coins: 12, bond: 25, duration: "10 min" }
                ],
                treatName: "Dog Biscuits",
                treatCost: 12
            },
            c: { // Bird (Parrot)
                name: "Bird",
                traits: ["Social", "Intelligent", "Vocal"],
                tasks: [
                    { id: "socialize", name: "Talk and interact", coins: 10, bond: 20, duration: "15 min" },
                    { id: "work", name: "Teach new words", coins: 15, bond: 30, duration: "20 min" },
                    { id: "play", name: "Play with toys", coins: 8, bond: 15, duration: "10 min" }
                ],
                treatName: "Spray Millet",
                treatCost: 15
            }
        };

        // 3D Scene Variables
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        let scene, camera, model, animations = {}, currentAnimGroup = null;

        // Bubble preview variables
        let bubbleEngines = {};
        let bubbleScenes = {};
        let bubbleModels = {};
        let selectedPetType = null;
        
        // Mini bubble variables for control panel
        let miniBubbleEngines = {};
        let miniBubbleScenes = {};
        let miniBubbleModels = {};

        const MODELS = {
            a: { file: "a.glb", name: "Cat" },
            b: { file: "b.glb", name: "Dog" },
            c: { file: "c.glb", name: "Bird" }
        };

        // ============================================
        // FIREBASE FUNCTIONS
        // ============================================
        
        async function loadPetData() {
            // Show loading for initial page load
            showLoading('Loading your pets...');
            
            // Firebase ONLY - no localStorage fallback
            if (!isFirebaseConfigured) {
                showAlert("Firebase is not configured! Please add your Firebase config to home.html");
                hideLoading();
                return;
            }
            
            if (!currentUser) {
                console.log("â³ Waiting for authentication...");
                hideLoading();
                return;
            }

            try {
                // Load all pets for this user from Firestore
                const petsSnapshot = await db.collection('users').doc(currentUser.uid).collection('pets').get();
                
                // Load USER DATA (coins, budget) - IMPORTANT!
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                if (userDoc.exists && userDoc.data().userData) {
                    userData = userDoc.data().userData;
                    console.log("âœ… Loaded userData:", userData);
                }
                
                if (!petsSnapshot.empty) {
                    userPets = {};
                    petsSnapshot.forEach(doc => {
                        const pet = doc.data();
                        // Migrate hunger to fullness if needed
                        if (pet.hunger !== undefined && pet.fullness === undefined) {
                            pet.fullness = 100 - pet.hunger;
                            delete pet.hunger;
                        }
                        userPets[doc.id] = pet;
                    });
                    
                    // Load last active pet
                    if (userDoc.exists && userDoc.data().currentPetId) {
                        currentPetId = userDoc.data().currentPetId;
                        if (userPets[currentPetId]) {
                            petData = userPets[currentPetId];
                            updateUI();
                            loadModel(MODELS[petData.type].file);
                            loadMiniBubbles();
                            // Hide loading after model loads (500ms delay for smooth transition)
                            setTimeout(() => hideLoading(), 500);
                            return;
                        }
                    }
                    
                    // Load first pet if no current pet selected
                    const firstPetId = Object.keys(userPets)[0];
                    if (firstPetId) {
                        currentPetId = firstPetId;
                        petData = userPets[firstPetId];
                        await db.collection('users').doc(currentUser.uid).set({
                            currentPetId: currentPetId,
                            userData: userData
                        }, { merge: true });
                        updateUI();
                        loadModel(MODELS[petData.type].file);
                        loadMiniBubbles();
                        // Hide loading after model loads (500ms delay for smooth transition)
                        setTimeout(() => hideLoading(), 500);
                    }
                } else {
                    // No pets yet - show setup
                    hideLoading();
                    showSetupModal();
                }
            } catch (error) {
                console.error("Error loading pet data from Firestore:", error);
                showAlert("Error loading pet data. Check console for details.");
                hideLoading();
            }
        }


        async function savePetData() {
            petData.lastUpdated = Date.now();
            
            // Safety check: prevent negative coins
            if (userData.coins < 0) {
                userData.coins = 0;
            }
            
            // Update in memory
            if (currentPetId) {
                userPets[currentPetId] = petData;
            }
            
            // Firebase ONLY - no localStorage
            if (!isFirebaseConfigured) {
                console.error("Firebase not configured!");
                return;
            }
            
            if (!currentUser) {
                console.log("Not authenticated - data not saved");
                return;
            }

            try {
                // Save current pet to Firestore
                await db.collection('users').doc(currentUser.uid).collection('pets').doc(currentPetId).set(petData);
                
                // Save current pet ID AND userData
                await db.collection('users').doc(currentUser.uid).set({
                    currentPetId: currentPetId,
                    userData: userData  // SAVE USER DATA!
                }, { merge: true });
                
                console.log("âœ… Pet data and userData saved to Firestore");
            } catch (error) {
                console.error("âŒ Error saving pet data:", error);
            }
        }

        function showSetupModal() {
            // Show loading while 3D models load
            showLoading('Loading pet options...');
            
            document.getElementById('setupModal').classList.add('active');
            
            // Track how many models have loaded
            let modelsLoaded = 0;
            const totalModels = 3;
            
            const checkAllLoaded = () => {
                modelsLoaded++;
                if (modelsLoaded === totalModels) {
                    // All 3 pet models loaded, hide loading
                    setTimeout(() => hideLoading(), 500);
                }
            };
            
            // Load 3D previews for each pet type after a short delay
            setTimeout(() => {
                loadBubblePreview('a', checkAllLoaded);
                loadBubblePreview('b', checkAllLoaded);
                loadBubblePreview('c', checkAllLoaded);
            }, 100);
        }

        function loadBubblePreview(petType, onLoadCallback) {
            const canvasId = `bubbleCanvas_${petType}`;
            const canvas = document.getElementById(canvasId);
            
            if (!canvas) {
                if (onLoadCallback) onLoadCallback();
                return;
            }
            
            // Create engine and scene for this bubble
            const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
            bubbleEngines[petType] = engine;
            
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(1, 1, 1, 1); // White background
            bubbleScenes[petType] = scene;
            
            // Camera - positioned to show front of pet (facing viewer)
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 4, BABYLON.Vector3.Zero(), scene);
            camera.lowerRadiusLimit = 3;
            camera.upperRadiusLimit = 6;
            camera.attachControl(canvas, true);
            
            // Lighting
            const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light1.intensity = 0.7;
            
            const light2 = new BABYLON.DirectionalLight("light2", new BABYLON.Vector3(-1, -2, -1), scene);
            light2.position = new BABYLON.Vector3(5, 10, 5);
            light2.intensity = 0.5;
            
            // Load model
            BABYLON.SceneLoader.ImportMesh("", "", MODELS[petType].file, scene, 
                (meshes) => {
                    const model = meshes[0];
                    bubbleModels[petType] = model;
                    
                    // Fix materials
                    model.getChildMeshes().forEach(mesh => {
                        if (mesh.material) {
                            const mat = mesh.material;
                            if (mat.getClassName() === "PBRMaterial") {
                                if (mat.albedoTexture && mat.albedoTexture.hasAlpha) {
                                    mat.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_ALPHATEST;
                                    mat.alphaCutOff = 0.5;
                                    mat.useAlphaFromAlbedoTexture = true;
                                } else {
                                    mat.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_OPAQUE;
                                }
                                if (!mat.metallicTexture) {
                                    mat.metallic = 0;
                                    mat.roughness = 1.0;
                                }
                                mat.backFaceCulling = true;
                            }
                        }
                    });
                    
                    // Position model
                    const bounds = model.getHierarchyBoundingVectors();
                    const size = bounds.max.subtract(bounds.min);
                    const scale = 2.0 / Math.max(size.x, size.y, size.z); // Reduced to 2.0 for smaller models
                    model.scaling.setAll(scale);
                    model.computeWorldMatrix(true);
                    
                    const newBounds = model.getHierarchyBoundingVectors();
                    const center = BABYLON.Vector3.Center(newBounds.min, newBounds.max);
                    
                    // Position lower - adjust Y to bring model down
                    model.position = new BABYLON.Vector3(-center.x, -newBounds.min.y - 0.5, -center.z);
                    
                    // Auto-rotate
                    scene.registerBeforeRender(() => {
                        model.rotation.y += 0.005;
                    });
                    
                    // Notify that model is loaded
                    if (onLoadCallback) onLoadCallback();
                },
                null,
                (scene, message, exception) => {
                    console.error(`Error loading ${petType} model:`, message);
                    // Even on error, call callback to prevent infinite loading
                    if (onLoadCallback) onLoadCallback();
                }
            );
            
            // Render loop
            engine.runRenderLoop(() => scene.render());
        }

        function selectPetBubble(petType) {
            selectedPetType = petType;
            
            // Update UI
            document.querySelectorAll('.pet-bubble').forEach(bubble => {
                bubble.classList.remove('selected');
            });
            document.querySelector(`[data-type="${petType}"]`).classList.add('selected');
            
            // Update background color of selected bubble's scene
            Object.keys(bubbleScenes).forEach(type => {
                if (type === petType) {
                    bubbleScenes[type].clearColor = new BABYLON.Color4(0.29, 0.61, 0.61, 1); // Teal
                } else {
                    bubbleScenes[type].clearColor = new BABYLON.Color4(1, 1, 1, 1); // White
                }
            });
        }

        function scrollPets(direction) {
            const container = document.getElementById('petBubblesContainer');
            const scrollAmount = 320; // bubble width + gap
            container.scrollLeft += direction * scrollAmount;
        }

        async function savePetSetup() {
            const name = document.getElementById('petNameInput').value.trim();
            
            if (!name) {
                showAlert("Please enter a pet name!");
                return;
            }
            
            if (!selectedPetType) {
                showAlert("Please select a pet type!");
                return;
            }

            // Show loading while creating pet
            showLoading('Creating ' + name + '...');

            // Create new pet with unique ID
            const newPetId = Date.now().toString(); // Simple unique ID
            const newPet = {
                name: name,
                type: selectedPetType,
                age: "baby",
                level: 1,
                experience: 0,
                experienceToNextLevel: 100,
                health: 100,
                happiness: 100,
                fullness: 100,
                energy: 100,
                coins: 100,
                bond: 0,
                totalSpent: 0,
                treats: {},
                tasksCompleted: {},
                lastTaskReset: Date.now(),
                adoptionDate: Date.now(),
                usingAITasks: false,
                lastUpdated: Date.now()
            };
            
            // Add to userPets
            userPets[newPetId] = newPet;
            currentPetId = newPetId;
            petData = newPet;
            
            console.log("âœ… Created new pet:", newPetId, newPet);
            console.log("ðŸ“¦ Total pets:", Object.keys(userPets).length);
            
            // Cleanup bubble engines
            Object.values(bubbleEngines).forEach(engine => {
                engine.stopRenderLoop();
                engine.dispose();
            });
            bubbleEngines = {};
            bubbleScenes = {};
            bubbleModels = {};
            
            document.getElementById('setupModal').classList.remove('active');
            
            updateUI();
            await savePetData();
            loadModel(MODELS[selectedPetType].file);
            loadMiniBubbles();
            
            // Hide loading after everything is set up
            setTimeout(() => hideLoading(), 800);
        }

        // ============================================
        // XP AND LEVELING SYSTEM
        // ============================================
        
        function gainExperience(amount) {
            if (!petData.experience) petData.experience = 0;
            if (!petData.level) petData.level = 1;
            if (!petData.experienceToNextLevel) petData.experienceToNextLevel = 100;
            
            petData.experience += amount;
            
            // Check for level up
            if (petData.experience >= petData.experienceToNextLevel) {
                levelUp();
            }
            
            updateUI();
            savePetData();
        }
        
        function levelUp() {
            petData.level += 1;
            petData.experience -= petData.experienceToNextLevel;
            petData.experienceToNextLevel = Math.floor(petData.experienceToNextLevel * 1.5); // 50% more XP needed each level
            
            // Bonus rewards for leveling up
            userData.coins += 50;
            petData.health = Math.min(100, petData.health + 20);
            petData.happiness = Math.min(100, petData.happiness + 20);
            
            // Show level up notification
            showFeedback(`Level Up! Now Level ${petData.level}! +50 coins bonus!`);
        }
        
        // ============================================
        // AI CHAT & EVENTS
        // ============================================
        
        async function sendPremadeMessage(message) {
            if (!message) return;
            
            // Add user message to chat
            addChatMessage(message, 'user');
            
            // Show loading
            const loadingMsg = addChatMessage('...', 'pet');
            
            // Get AI response
            const response = await chatWithPet(message);
            
            // Remove loading and add real response
            loadingMsg.remove();
            if (response) {
                addChatMessage(response, 'pet');
            } else {
                addChatMessage("*looks confused* Make sure you added GROQ_API_KEY to Vercel environment variables!", 'pet');
            }
        }
        
        function addChatMessage(text, sender) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;
            messageDiv.textContent = text;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            return messageDiv;
        }
        
        async function refreshAITasks() {
            // Check if triggered by button or auto-load
            const button = event ? event.target.closest('.ai-button') : null;
            let originalText = '';
            
            if (button) {
                originalText = button.innerHTML;
                button.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"></path></svg> Loading...';
                button.disabled = true;
            }
            
            const aiTasks = await generateAIDailyTasks();
            
            if (aiTasks) {
                // Store AI tasks and set flag
                petData.aiTasks = aiTasks;
                petData.usingAITasks = true;
                
                // Display AI tasks
                displayTasks(aiTasks);
                savePetData();
            } else {
                showAlert("Failed to generate AI tasks. Make sure you added GROQ_API_KEY to Vercel environment variables!", 'error');
            }
            
            if (button) {
                button.innerHTML = originalText;
                button.disabled = false;
            }
        }
        
        
        // ============================================
        // DYNAMIC SCENARIO SYSTEM
        // ============================================
        
        async function generateScenario() {
            const context = getPetPersonalityContext();
            const traits = PET_TRAITS[petData.type];
            
            const prompt = `${context}

Generate a random scenario that affects your stats as a ${traits.name}. This should be a realistic event that happens to pets.

SCENARIO TYPES:
- Got sick (decrease health by 15-30)
- Found food/ate something (increase fullness by 10-20, might decrease health if bad food)
- Got scared/stressed (decrease happiness by 15-25)
- Had fun adventure (increase happiness by 10-20, decrease energy by 10-15)
- Played too hard (decrease energy by 20-30)
- Took a great nap (increase energy by 15-25)
- Made a mess (decrease happiness by 5-10)

Return ONLY a JSON object in this exact format (no markdown):
{
  "title": "brief scenario title (e.g., 'Got Sick!', 'Found a Treat!')",
  "description": "what happened in first person (20-40 words, emotional)",
  "effects": {
    "health": -20,
    "happiness": 0,
    "fullness": 0,
    "energy": 0
  }
}

RULES:
- Only change 1-2 stats per scenario
- Negative events: health -15 to -30, happiness -15 to -25, energy -20 to -30
- Positive events: happiness +10 to +20, energy +15 to +25, fullness +10 to +20
- Make it realistic for a ${traits.name}
- Effects must be numbers (positive or negative)

Examples:
{"title": "Ate Something Bad!", "description": "I found some old food under the couch and ate it... my tummy hurts now!", "effects": {"health": -25, "happiness": -10, "fullness": 5, "energy": 0}}
{"title": "Had a Great Nap!", "description": "I found the sunniest spot in the house and took the best nap ever! I feel so refreshed!", "effects": {"health": 0, "happiness": 15, "fullness": 0, "energy": 20}}`;

            const response = await callGroqAPI(prompt);
            
            if (response) {
                try {
                    let cleanResponse = response.trim();
                    if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '');
                    }
                    return JSON.parse(cleanResponse);
                } catch (e) {
                    console.error("Failed to parse scenario:", e);
                    return null;
                }
            }
            return null;
        }
        
        function applyScenarioEffects(scenario) {
            // Apply stat changes
            const effects = scenario.effects;
            
            if (effects.health) {
                petData.health = Math.max(0, Math.min(100, petData.health + effects.health));
            }
            if (effects.happiness) {
                petData.happiness = Math.max(0, Math.min(100, petData.happiness + effects.happiness));
            }
            if (effects.fullness) {
                petData.fullness = Math.max(0, Math.min(100, petData.fullness + effects.fullness));
            }
            if (effects.energy) {
                petData.energy = Math.max(0, Math.min(100, petData.energy + effects.energy));
            }
            
            // Build effect message
            let effectMsg = '\n\nStat Changes:\n';
            if (effects.health) effectMsg += `Health: ${effects.health > 0 ? '+' : ''}${effects.health}\n`;
            if (effects.happiness) effectMsg += `Happiness: ${effects.happiness > 0 ? '+' : ''}${effects.happiness}\n`;
            if (effects.fullness) effectMsg += `Fullness: ${effects.fullness > 0 ? '+' : ''}${effects.fullness}\n`;
            if (effects.energy) effectMsg += `Energy: ${effects.energy > 0 ? '+' : ''}${effects.energy}\n`;
            
            // Show alert
            showAlert(
                `${scenario.title}\n\n${scenario.description}${effectMsg}`,
                effects.health < 0 || effects.happiness < -10 ? 'error' : 'info'
            );
            
            // Update UI and save
            updateUIWithoutTasks();
            savePetData();
        }
        
        async function checkForScenario() {
            // Random scenarios every 20-60 minutes
            const randomMinutes = Math.random() * 40 + 20; // 20-60 minutes
            
            setTimeout(async () => {
                const scenario = await generateScenario();
                
                if (scenario) {
                    applyScenarioEffects(scenario);
                }
                
                // Schedule next scenario
                checkForScenario();
            }, randomMinutes * 60 * 1000);
        }
        
        async function checkForRandomEvent() {
            // Only check if AI is enabled
            if (!isAIEnabled()) return;
            
            // REDUCED frequency to save Groq tokens
            let eventChance = 0.03; // Base 3% chance per check (was 15%)
            
            // Increase chance only for critical needs
            if (petData.fullness < 20) eventChance += 0.05;
            if (petData.happiness < 30) eventChance += 0.05;
            if (petData.health < 30) eventChance += 0.03;
            
            // Memory event after 30 days (guaranteed)
            const daysSinceAdoption = Math.floor((Date.now() - (petData.adoptionDate || Date.now())) / (1000 * 60 * 60 * 24));
            if (daysSinceAdoption >= 30 && !petData.had30DayMemory) {
                petData.had30DayMemory = true;
                const event = await generateRandomEvent();
                if (event) {
                    showRandomEvent(event);
                    savePetData();
                }
                return;
            }
            
            // Random event based on dynamic chance
            if (Math.random() < eventChance) {
                const event = await generateRandomEvent();
                
                if (event) {
                    showRandomEvent(event);
                }
            }
        }
        
        function showRandomEvent(event) {
            const eventSection = document.getElementById('eventsSection');
            const eventCard = document.getElementById('eventCard');
            
            eventCard.innerHTML = `
                <div class="event-title">${event.event}</div>
                <div class="event-dialogue">"${event.dialogue}"</div>
            `;
            
            eventSection.style.display = 'block';
            
            // Hide after 15 seconds (longer for memories)
            setTimeout(() => {
                eventSection.style.display = 'none';
            }, 15000);
        }
        
        // Check for events periodically (only if AI enabled)
        setInterval(() => {
            checkForRandomEvent();
        }, 60000); // Check every minute
        
        // ============================================
        // PET CARE FUNCTIONS
        // ============================================

        function feedPet() {
            const COST = 10;
            
            // Check coins
            if (userData.coins < COST) {
                showAlert("Not enough coins! You need $" + COST + " to feed your pet.", 'error');
                return;
            }
            
            // Check budget
            if (userData.costTracking && userData.costTracking.budgetRemaining < COST) {
                showAlert("Monthly budget exceeded! You've spent $" + userData.costTracking.totalSpent + " this month.", 'error');
                return;
            }
            
            if (petData.fullness > 80) {
                showAlert("Your pet is already full!", 'warning');
                return;
            }

            // DEDUCT coins (never add!)
            userData.coins -= COST;
            
            // Track expense
            if (!userData.costTracking) {
                userData.costTracking = {
                    totalSpent: 0, foodSpent: 0, vetSpent: 0, toySpent: 0,
                    monthlyBudget: 200, budgetRemaining: 200, transactions: [], lastMonthReset: Date.now()
                };
            }
            userData.costTracking.totalSpent += COST;
            userData.costTracking.foodSpent += COST;
            userData.costTracking.budgetRemaining -= COST;
            
            // Apply effects
            petData.fullness = Math.min(100, petData.fullness + 30);
            petData.health = Math.min(100, petData.health + 5);
            petData.happiness = Math.min(100, petData.happiness + 10);
            
            gainExperience(10);
            updateUI();
            savePetData();
            showFeedback("Fed your pet! +10 XP");
        }

        function playWithPet() {
            const COST = 15;
            
            if (userData.coins < COST) {
                showAlert("Not enough coins! You need $" + COST + " for toys.", 'error');
                return;
            }
            
            // Check budget
            if (userData.costTracking && userData.costTracking.budgetRemaining < COST) {
                showAlert("Monthly budget exceeded! You've spent $" + userData.costTracking.totalSpent + " this month.", 'error');
                return;
            }
            
            if (petData.energy < 20) {
                showAlert("Your pet is too tired to play!", 'warning');
                return;
            }

            // DEDUCT coins (never add!)
            userData.coins -= COST;
            
            // Track expense
            if (!userData.costTracking) {
                userData.costTracking = {
                    totalSpent: 0, foodSpent: 0, vetSpent: 0, toySpent: 0,
                    monthlyBudget: 200, budgetRemaining: 200, transactions: [], lastMonthReset: Date.now()
                };
            }
            userData.costTracking.totalSpent += COST;
            userData.costTracking.toySpent += COST;
            userData.costTracking.budgetRemaining -= COST;
            
            // Apply effects
            petData.happiness = Math.min(100, petData.happiness + 20);
            petData.energy = Math.max(0, petData.energy - 15);
            petData.fullness = Math.max(0, petData.fullness - 10);
            
            gainExperience(15);
            updateUI();
            savePetData();
            showFeedback("Played with your pet! +15 XP");
        }
        

        function restPet() {
            if (petData.energy > 80) {
                showAlert("Your pet isn't tired right now!");
                return;
            }

            petData.energy = Math.min(100, petData.energy + 40); // INCREASE energy (resting restores)
            petData.health = Math.min(100, petData.health + 5);
            
            gainExperience(5); // +5 XP for resting
            updateUI();
            savePetData();
            showFeedback("Your pet rested! Energy restored. +5 XP");
        }

        function healthCheck() {
            const COST = 50;
            
            if (userData.coins < COST) {
                showAlert("Not enough coins! Vet visit costs $" + COST + ".", 'error');
                return;
            }
            
            // Check budget
            if (userData.costTracking && userData.costTracking.budgetRemaining < COST) {
                showAlert("Monthly budget exceeded! You've spent $" + userData.costTracking.totalSpent + " this month.", 'error');
                return;
            }

            // DEDUCT coins (never add!)
            userData.coins -= COST;
            
            // Track expense
            if (!userData.costTracking) {
                userData.costTracking = {
                    totalSpent: 0, foodSpent: 0, vetSpent: 0, toySpent: 0,
                    monthlyBudget: 200, budgetRemaining: 200, transactions: [], lastMonthReset: Date.now()
                };
            }
            userData.costTracking.totalSpent += COST;
            userData.costTracking.vetSpent += COST;
            userData.costTracking.budgetRemaining -= COST;
            
            // Apply effects
            petData.health = 100;
            
            gainExperience(20);
            updateUI();
            savePetData();
            
            let diagnosis = "Your pet is healthy!";
            if (petData.fullness < 30) diagnosis += "\nBut very hungry - please feed soon!";
            if (petData.energy < 30) diagnosis += "\nLow energy - let them rest!";
            
            showAlert("Vet Check-up Complete! +20 XP\n\n" + diagnosis, 'success');
        }

        function showFeedback(message) {
            // Feedback disabled - messages removed
            // You can re-enable by uncommenting below:
            /*
            const overlay = document.querySelector('.scene-info');
            const feedback = document.createElement('div');
            feedback.style.cssText = 'position: absolute; top: -50px; left: 50%; transform: translateX(-50%); background: #4A9B9B; color: white; padding: 0.75rem 1.5rem; border-radius: 8px; font-weight: 600; white-space: nowrap; animation: slideDown 3s ease;';
            feedback.textContent = message;
            overlay.appendChild(feedback);
            setTimeout(() => feedback.remove(), 3000);
            */
        }

        // ============================================
        // STATS UPDATE & TIME-BASED DECAY
        // ============================================

        function updateStatsOverTime() {
            const now = Date.now();
            const hoursPassed = (now - petData.lastUpdated) / (1000 * 60 * 60);
            
            if (hoursPassed > 0.1) { // Update if more than 6 minutes passed
                // REALISTIC STAT DECAY (like real pets)
                
                // FULLNESS (Hunger) - decreases every 4-6 hours (realistic meal timing)
                // Dogs/cats eat 2-3 times per day
                petData.fullness = Math.max(0, petData.fullness - (hoursPassed * 3)); // ~8 hours to get hungry
                
                // ENERGY - decreases during day, should rest at night
                // Pets need 12-14 hours sleep per day
                petData.energy = Math.max(0, petData.energy - (hoursPassed * 1.5)); // ~16 hours to get tired
                
                // HAPPINESS - decreases slowly if not played with
                // Pets need attention/play daily
                petData.happiness = Math.max(0, petData.happiness - (hoursPassed * 1)); // ~24 hours without play = sad
                
                // HEALTH - only decreases in specific conditions (realistic)
                // Health doesn't naturally decay fast in real life
                
                // Critical hunger affects health (starving)
                if (petData.fullness < 10) {
                    petData.health = Math.max(0, petData.health - (hoursPassed * 5)); // Starving = serious
                } 
                // Very hungry affects health slowly
                else if (petData.fullness < 30) {
                    petData.health = Math.max(0, petData.health - (hoursPassed * 0.5)); // Minor health impact
                }
                
                // Exhaustion affects health
                if (petData.energy < 10) {
                    petData.health = Math.max(0, petData.health - (hoursPassed * 2)); // Sleep deprivation
                }
                
                // Unhappiness affects health long-term (stress/depression)
                if (petData.happiness < 20) {
                    petData.health = Math.max(0, petData.health - (hoursPassed * 0.3)); // Chronic stress
                }
                
                petData.lastUpdated = now;
                savePetData();
            }
        }

        // Auto-update stats every minute
        setInterval(() => {
            updateStatsOverTime();
            updateUIWithoutTasks(); // Don't reload tasks!
        }, 60000);

        function updateCostUI() {
            // Initialize costTracking if it doesn't exist
            if (!userData.costTracking) {
                userData.costTracking = {
                    totalSpent: 0,
                    foodSpent: 0,
                    vetSpent: 0,
                    toySpent: 0,
                    monthlyBudget: 200,
                    budgetRemaining: 200,
                    transactions: []
                };
            }
            
            const cost = userData.costTracking;
            
            document.getElementById('monthlyBudget').textContent = cost.monthlyBudget;
            document.getElementById('budgetRemaining').textContent = '$' + Math.max(0, cost.budgetRemaining);
            document.getElementById('foodSpent').textContent = cost.foodSpent;
            document.getElementById('vetSpent').textContent = cost.vetSpent;
            document.getElementById('toySpent').textContent = cost.toySpent;
            
            // Update total spent (IMPORTANT!)
            if (document.getElementById('totalSpent')) {
                document.getElementById('totalSpent').textContent = cost.totalSpent || 0;
            }
            
            // Update budget bar
            const budgetPercent = Math.max(0, (cost.budgetRemaining / cost.monthlyBudget) * 100);
            const budgetBar = document.getElementById('budgetBar');
            budgetBar.style.width = budgetPercent + '%';
            
            // Warning colors when budget is low
            const remaining = document.getElementById('budgetRemaining');
            if (budgetPercent < 20) {
                budgetBar.classList.add('low');
                remaining.classList.add('low');
            } else {
                budgetBar.classList.remove('low');
                remaining.classList.remove('low');
            }
        }

        function updateUI() {
            document.getElementById('petNameDisplay').textContent = petData.name;
            
            // Ensure coins never display negative
            const coins = Math.max(0, userData.coins || 0);
            document.getElementById('coinsStat').textContent = coins;
            
            // Update age
            const age = petData.age || 'baby';
            const ageInfo = AGE_STAGES[age];
            document.getElementById('ageValue').textContent = ageInfo.label;
            
            // Update level and XP
            document.getElementById('levelNum').textContent = petData.level || 1;
            document.getElementById('currentXP').textContent = petData.experience || 0;
            document.getElementById('maxXP').textContent = petData.experienceToNextLevel || 100;
            const xpPercentage = ((petData.experience || 0) / (petData.experienceToNextLevel || 100)) * 100;
            document.getElementById('levelBar').style.width = xpPercentage + '%';
            
            // Update bond and show next milestone
            const bond = petData.bond || 0;
            document.getElementById('bondValue').textContent = bond;
            document.getElementById('bondBar').style.width = bond + '%';
            
            // Show next age milestone
            const milestoneEl = document.getElementById('bondMilestone');
            if (bond < 25) {
                milestoneEl.textContent = 'Next: 25 bond needed to become Young';
            } else if (bond < 50) {
                milestoneEl.textContent = 'Next: 50 bond needed to become Adult';
            } else if (bond < 75) {
                milestoneEl.textContent = 'Next: 75 bond needed to become Senior';
            } else {
                milestoneEl.textContent = 'Maximum bond reached!';
            }
            
            // Update stats
            document.getElementById('healthStat').textContent = petData.health.toFixed(0);
            document.getElementById('happinessStat').textContent = petData.happiness.toFixed(0);
            document.getElementById('fullnessStat').textContent = petData.fullness.toFixed(0);
            document.getElementById('energyStat').textContent = petData.energy.toFixed(0);
            
            // Update progress bars
            document.getElementById('healthBar').style.width = petData.health + '%';
            document.getElementById('happinessBar').style.width = petData.happiness + '%';
            document.getElementById('fullnessBar').style.width = petData.fullness + '%';
            document.getElementById('energyBar').style.width = petData.energy + '%';
            
            // Update mood display
            updateMood();
            
            // Update cost tracking display
            updateCostUI();
            
            // Update pet-specific UI
            loadPetTraits();
            loadPetTasks();
            
            // Update mini bubble selection if bubbles are loaded
            if (typeof miniBubbleEngines !== 'undefined' && Object.keys(miniBubbleEngines).length > 0) {
                updateMiniBubbleSelection();
            }
        }
        
        function loadPetTraits() {
            const traits = PET_TRAITS[petData.type];
            if (!traits) return;
            
            const traitTagsContainer = document.getElementById('traitTags');
            traitTagsContainer.innerHTML = '';
            
            traits.traits.forEach(trait => {
                const tag = document.createElement('span');
                tag.className = 'trait-tag';
                tag.textContent = trait;
                traitTagsContainer.appendChild(tag);
            });
        }
        
        function loadPetTasks() {
            const traits = PET_TRAITS[petData.type];
            if (!traits) return;
            
            const taskListContainer = document.getElementById('taskList');
            taskListContainer.innerHTML = '';
            
            // Initialize tasksCompleted if not exists
            if (!petData.tasksCompleted) petData.tasksCompleted = {};
            
            // Reset daily tasks (24 hour cycle)
            const now = Date.now();
            const lastReset = petData.lastTaskReset || 0;
            const hoursSinceReset = (now - lastReset) / (1000 * 60 * 60);
            
            if (hoursSinceReset >= 24) {
                petData.tasksCompleted = {};
                petData.lastTaskReset = now;
                petData.usingAITasks = false; // Reset to default tasks
                savePetData();
            }
            
            // Use AI tasks if available AND flag is set, otherwise use default tasks
            const tasksToShow = (petData.usingAITasks && petData.aiTasks && petData.aiTasks.length > 0) 
                ? petData.aiTasks 
                : traits.tasks;
            
            displayTasks(tasksToShow);
        }
        
        function displayTasks(tasks) {
            const taskListContainer = document.getElementById('taskList');
            taskListContainer.innerHTML = '';
            
            // Task icons
            const taskIcons = {
                'playtime': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M8 15h8M9 9h.01M15 9h.01"></path></svg>',
                'socialize': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>',
                'explore': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path></svg>',
                'run': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path></svg>',
                'fetch': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4M12 8h.01"></path></svg>',
                'train': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>',
                'work': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>',
                'play': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>'
            };
            
            // AI icon (sparkles)
            const aiIcon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"></path></svg>';
            
            tasks.forEach(task => {
                const taskDiv = document.createElement('div');
                taskDiv.className = 'task-item';
                
                const isCompleted = petData.tasksCompleted[task.id];
                if (isCompleted) {
                    taskDiv.classList.add('completed');
                }
                
                // Use specific icon or AI icon for AI tasks
                const iconSvg = taskIcons[task.id] || aiIcon;
                
                taskDiv.innerHTML = `
                    <div class="task-header">
                        <span class="task-icon">${iconSvg}</span>
                        <div class="task-name">${task.name}</div>
                    </div>
                    <div class="task-duration">
                        <svg class="inline-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polyline points="12 6 12 12 16 14"></polyline>
                        </svg>
                        ${task.duration}
                    </div>
                    <div class="task-reward">
                        <span class="task-coins">
                            <svg class="inline-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M12 6v12M9 9h6M9 15h6"></path>
                            </svg>
                            +${task.coins} coins
                        </span>
                        <span class="task-bond">
                            <svg class="inline-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                            </svg>
                            +${task.bond} bond
                        </span>
                    </div>
                    ${isCompleted ? '<span class="task-checkmark"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"></polyline></svg></span>' : ''}
                `;
                
                if (!isCompleted) {
                    taskDiv.onclick = () => startTask(task, taskDiv);
                }
                
                taskListContainer.appendChild(taskDiv);
            });
        }
        
        // Active timers tracking
        const activeTimers = {};
        
        function startTask(task, taskElement) {
            // Parse duration
            const durationMatch = task.duration.match(/(\d+)/);
            if (!durationMatch) return;
            
            const durationMinutes = parseInt(durationMatch[1]);
            const durationSeconds = durationMinutes * 60;
            
            // Prevent multiple timers on same task
            if (activeTimers[task.id]) {
                clearInterval(activeTimers[task.id]);
            }
            
            // Save original content
            const originalContent = taskElement.innerHTML;
            
            // Mark as in progress
            taskElement.classList.add('in-progress');
            taskElement.style.minHeight = '200px';
            
            // Create timer display
            const radius = 50;
            const circumference = 2 * Math.PI * radius;
            
            taskElement.innerHTML = `
                <div class="task-timer">
                    <svg class="timer-svg" width="120" height="120">
                        <circle class="timer-circle-bg" cx="60" cy="60" r="${radius}"></circle>
                        <circle class="timer-circle-progress" cx="60" cy="60" r="${radius}"
                            style="stroke-dasharray: ${circumference}; stroke-dashoffset: 0;"></circle>
                    </svg>
                    <div class="timer-text">${durationMinutes}:00</div>
                </div>
            `;
            
            const progressCircle = taskElement.querySelector('.timer-circle-progress');
            const timerText = taskElement.querySelector('.timer-text');
            
            let remainingSeconds = durationSeconds;
            
            // Simple setInterval - runs every second
            const intervalId = setInterval(() => {
                remainingSeconds--;
                
                // Update display
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                timerText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Update circle progress
                const progress = remainingSeconds / durationSeconds;
                const offset = circumference * (1 - progress);
                progressCircle.style.strokeDashoffset = offset;
                
                // Check if done
                if (remainingSeconds <= 0) {
                    clearInterval(intervalId);
                    delete activeTimers[task.id];
                    completeTask(task, taskElement, originalContent);
                }
            }, 1000);
            
            // Store interval ID
            activeTimers[task.id] = intervalId;
        }
        
        function completeTask(task, taskElement, originalContent) {
            // Mark task as completed
            if (!petData.tasksCompleted) petData.tasksCompleted = {};
            petData.tasksCompleted[task.id] = true;
            
            // Award rewards
            userData.coins = (userData.coins || 0) + task.coins;
            const oldBond = petData.bond || 0;
            petData.bond = Math.min(100, (petData.bond || 0) + task.bond);
            petData.happiness = Math.min(100, petData.happiness + 10);
            
            // Check for age progression
            checkAgeProgression(oldBond, petData.bond);
            
            // Give XP
            gainExperience(task.bond);
            
            // Restore original content and add checkmark
            if (taskElement && originalContent) {
                taskElement.classList.remove('in-progress');
                taskElement.classList.add('completed');
                taskElement.style.minHeight = '';
                
                // Restore original content
                taskElement.innerHTML = originalContent;
                
                // Add checkmark
                taskElement.innerHTML += '<span class="task-checkmark"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"></polyline></svg></span>';
                
                // Remove click handler
                taskElement.onclick = null;
            }
            
            // Update UI WITHOUT reloading tasks
            updateUIWithoutTasks();
            savePetData();
            
            showAlert(`Task completed! +${task.coins} coins, +${task.bond} bond!`, 'success');
        }
        
        // Update UI without reloading tasks (used during task completion)
        function updateUIWithoutTasks() {
            document.getElementById('petNameDisplay').textContent = petData.name;
            
            const coins = Math.max(0, userData.coins || 0);
            document.getElementById('coinsStat').textContent = coins;
            
            const age = petData.age || 'baby';
            const ageInfo = AGE_STAGES[age];
            document.getElementById('ageValue').textContent = ageInfo.label;
            
            document.getElementById('levelNum').textContent = petData.level || 1;
            document.getElementById('currentXP').textContent = petData.experience || 0;
            document.getElementById('maxXP').textContent = petData.experienceToNextLevel || 100;
            const xpPercentage = ((petData.experience || 0) / (petData.experienceToNextLevel || 100)) * 100;
            document.getElementById('levelBar').style.width = xpPercentage + '%';
            
            const bond = petData.bond || 0;
            document.getElementById('bondValue').textContent = bond;
            document.getElementById('bondBar').style.width = bond + '%';
            
            const milestoneEl = document.getElementById('bondMilestone');
            if (bond < 25) {
                milestoneEl.textContent = 'Next: 25 bond needed to become Young';
            } else if (bond < 50) {
                milestoneEl.textContent = 'Next: 50 bond needed to become Adult';
            } else if (bond < 75) {
                milestoneEl.textContent = 'Next: 75 bond needed to become Senior';
            } else {
                milestoneEl.textContent = 'Maximum bond reached!';
            }
            
            document.getElementById('healthStat').textContent = petData.health.toFixed(0);
            document.getElementById('happinessStat').textContent = petData.happiness.toFixed(0);
            document.getElementById('fullnessStat').textContent = petData.fullness.toFixed(0);
            document.getElementById('energyStat').textContent = petData.energy.toFixed(0);
            
            document.getElementById('healthBar').style.width = petData.health + '%';
            document.getElementById('happinessBar').style.width = petData.happiness + '%';
            document.getElementById('fullnessBar').style.width = petData.fullness + '%';
            document.getElementById('energyBar').style.width = petData.energy + '%';
            
            updateMood();
            updateCostUI();
        }
        
        function checkAgeProgression(oldBond, newBond) {
            const currentAge = petData.age || 'baby';
            let newAge = currentAge;
            
            // Determine new age based on bond level
            for (const [ageKey, ageData] of Object.entries(AGE_STAGES)) {
                if (newBond >= ageData.minBond && newBond <= ageData.maxBond) {
                    newAge = ageKey;
                    break;
                }
            }
            
            // If age changed, show notification and update model scale
            if (newAge !== currentAge) {
                petData.age = newAge;
                const ageInfo = AGE_STAGES[newAge];
                
                showFeedback(`Your pet grew! Now a ${ageInfo.label}!`);
                
                // Update 3D model scale
                if (model) {
                    model.scaling.setAll(ageInfo.scale);
                }
            }
        }
        
        function updateMood() {
            const moodDisplay = document.getElementById('moodDisplay');
            const moodIcon = moodDisplay.querySelector('.mood-icon');
            
            // Remove all mood classes
            moodDisplay.classList.remove('happy', 'sad', 'sick', 'energetic');
            
            // Determine mood based on stats
            // Priority: Sick > Sad > Energetic > Happy
            
            if (petData.health < 30) {
                // Sick - Low health
                moodDisplay.classList.add('sick');
                moodIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M8 15h8M9 9h.01M15 9h.01"></path></svg>';
                moodDisplay.title = 'Sick - Needs medical attention!';
            } else if (petData.happiness < 40 || petData.fullness < 30) {
                // Sad - Low happiness or very hungry
                moodDisplay.classList.add('sad');
                moodIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>';
                moodDisplay.title = 'Sad - Needs care and attention';
            } else if (petData.energy > 80 && petData.happiness > 70) {
                // Energetic - High energy and happy
                moodDisplay.classList.add('energetic');
                moodIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><circle cx="9" cy="9" r="1" fill="currentColor"></circle><circle cx="15" cy="9" r="1" fill="currentColor"></circle></svg>';
                moodDisplay.title = 'Energetic - Ready to play!';
            } else if (petData.happiness > 70 && petData.health > 70) {
                // Happy - Good stats overall
                moodDisplay.classList.add('happy');
                moodIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>';
                moodDisplay.title = 'Happy - Feeling great!';
            } else {
                // Neutral/Content
                moodIcon.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>';
                moodDisplay.title = 'Neutral - Doing okay';
            }
        }

        function changePetType() {
            const newType = document.getElementById('modelSelect').value;
            petData.type = newType;
            savePetData();
            loadModel(MODELS[newType].file);
        }
        
        // Mini bubble system for control panel
        function loadMiniBubbles() {
            const container = document.getElementById('miniPetBubblesContainer');
            container.innerHTML = ''; // Clear existing
            
            // Cleanup old engines
            Object.values(miniBubbleEngines).forEach(engine => {
                engine.stopRenderLoop();
                engine.dispose();
            });
            miniBubbleEngines = {};
            miniBubbleScenes = {};
            miniBubbleModels = {};
            
            // Create bubble for each pet
            Object.keys(userPets).forEach(petId => {
                const pet = userPets[petId];
                
                // Create bubble container
                const bubbleDiv = document.createElement('div');
                bubbleDiv.className = 'mini-bubble';
                bubbleDiv.setAttribute('data-pet-id', petId);
                if (petId === currentPetId) {
                    bubbleDiv.classList.add('selected');
                }
                bubbleDiv.onclick = () => selectMiniPet(petId);
                
                // Create canvas for 3D preview
                const canvas = document.createElement('canvas');
                canvas.className = 'mini-bubble-canvas';
                canvas.id = `miniBubbleCanvas_${petId}`;
                bubbleDiv.appendChild(canvas);
                
                // Create label with pet name
                const label = document.createElement('div');
                label.className = 'mini-bubble-label';
                label.textContent = pet.name;
                bubbleDiv.appendChild(label);
                
                container.appendChild(bubbleDiv);
                
                // Load 3D preview
                setTimeout(() => loadMiniBubblePreview(petId, pet.type), 100);
            });
        }
        
        function loadMiniBubblePreview(petId, petType) {
            const canvasId = `miniBubbleCanvas_${petId}`;
            const canvas = document.getElementById(canvasId);
            
            if (!canvas) return;
            
            // Create engine and scene for this mini bubble
            const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
            miniBubbleEngines[petId] = engine;
            
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(1, 1, 1, 1);
            miniBubbleScenes[petId] = scene;
            
            // Camera
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 4, BABYLON.Vector3.Zero(), scene);
            camera.lowerRadiusLimit = 3;
            camera.upperRadiusLimit = 6;
            
            // Lighting
            const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light1.intensity = 0.7;
            
            const light2 = new BABYLON.DirectionalLight("light2", new BABYLON.Vector3(-1, -2, -1), scene);
            light2.position = new BABYLON.Vector3(5, 10, 5);
            light2.intensity = 0.5;
            
            // Load model
            BABYLON.SceneLoader.ImportMesh("", "", MODELS[petType].file, scene, 
                (meshes) => {
                    const model = meshes[0];
                    miniBubbleModels[petId] = model;
                    
                    // Fix materials
                    model.getChildMeshes().forEach(mesh => {
                        if (mesh.material) {
                            const mat = mesh.material;
                            if (mat.getClassName() === "PBRMaterial") {
                                if (mat.albedoTexture && mat.albedoTexture.hasAlpha) {
                                    mat.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_ALPHATEST;
                                    mat.alphaCutOff = 0.5;
                                    mat.useAlphaFromAlbedoTexture = true;
                                } else {
                                    mat.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_OPAQUE;
                                }
                                if (!mat.metallicTexture) {
                                    mat.metallic = 0;
                                    mat.roughness = 1.0;
                                }
                                mat.backFaceCulling = true;
                            }
                        }
                    });
                    
                    // Position model
                    const bounds = model.getHierarchyBoundingVectors();
                    const size = bounds.max.subtract(bounds.min);
                    const scale = 2.0 / Math.max(size.x, size.y, size.z);
                    model.scaling.setAll(scale);
                    model.computeWorldMatrix(true);
                    
                    const newBounds = model.getHierarchyBoundingVectors();
                    const center = BABYLON.Vector3.Center(newBounds.min, newBounds.max);
                    model.position = new BABYLON.Vector3(-center.x, -newBounds.min.y - 0.5, -center.z);
                    
                    // Auto-rotate
                    scene.registerBeforeRender(() => {
                        model.rotation.y += 0.005;
                    });
                }
            );
            
            // Render loop
            engine.runRenderLoop(() => scene.render());
        }
        
        let petSwitchTimeout = null;
        
        function selectMiniPet(petId) {
            // Debounce to prevent rapid switching
            if (petSwitchTimeout) {
                clearTimeout(petSwitchTimeout);
            }
            
            petSwitchTimeout = setTimeout(() => {
                // Show loading when switching pets
                showLoading('Switching to ' + userPets[petId].name + '...');
                
                currentPetId = petId;
                petData = userPets[petId];
                updateMiniBubbleSelection();
                updateUI();
                savePetData();
                loadModel(MODELS[petData.type].file);
                
                // Hide loading after model loads (with delay for smooth transition)
                setTimeout(() => hideLoading(), 800);
                
                petSwitchTimeout = null;
            }, 100); // 100ms debounce
        }
        
        function updateMiniBubbleSelection() {
            document.querySelectorAll('.mini-bubble').forEach(bubble => {
                bubble.classList.remove('selected');
            });
            const selectedBubble = document.querySelector(`[data-pet-id="${currentPetId}"]`);
            if (selectedBubble) {
                selectedBubble.classList.add('selected');
            }
        }

        // ============================================
        // 3D SCENE SETUP
        // ============================================

        function createScene() {
            scene = new BABYLON.Scene(engine);
            
            camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 3, 6, new BABYLON.Vector3(0, 1, 0), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 3;
            camera.upperRadiusLimit = 15;
            
            // Lock camera height (beta axis) - can't move up/down
            camera.lowerBetaLimit = Math.PI / 3; // Lock at this angle
            camera.upperBetaLimit = Math.PI / 3; // Same angle = locked
            
            // Lock vertical panning
            camera.panningSensibility = 0; // Disable panning entirely
            
            const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.6;
            
            const dirLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
            dirLight.position = new BABYLON.Vector3(5, 10, 5);
            dirLight.intensity = 0.8;
            
            // Create invisible ground - pet walks on background
            const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 30, height: 30 }, scene);
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            
            // Make completely transparent - pet appears to walk on background
            groundMat.alpha = 0; // Invisible platform
            groundMat.backFaceCulling = false;
            
            ground.material = groundMat;
            
            // Load background
            const panoramaTexture = new BABYLON.Texture("bg.jpg", scene);
            panoramaTexture.onLoadObservable.addOnce(() => {
                const skybox = BABYLON.MeshBuilder.CreateSphere("skybox", { diameter: 5000 }, scene);
                skybox.infiniteDistance = true;
                const skyMat = new BABYLON.StandardMaterial("skyMat", scene);
                skyMat.backFaceCulling = false;
                skyMat.emissiveTexture = panoramaTexture;
                skyMat.emissiveTexture.coordinatesMode = BABYLON.Texture.FIXED_EQUIRECTANGULAR_MODE;
                skyMat.emissiveTexture.vScale = -1;
                skyMat.disableLighting = true;
                skybox.material = skyMat;
            });
            
            return scene;
        }

        // Custom Alert System
        function showAlert(message, type = 'info') {
            const alertEl = document.getElementById('customAlert');
            const messageEl = document.getElementById('alertMessage');
            const iconEl = document.getElementById('alertIcon');
            
            messageEl.textContent = message;
            
            // Set icon based on type
            if (type === 'error') {
                iconEl.textContent = 'âŒ';
            } else if (type === 'success') {
                iconEl.textContent = 'âœ…';
            } else if (type === 'warning') {
                iconEl.textContent = 'âš ï¸';
            } else {
                iconEl.textContent = 'â„¹ï¸';
            }
            
            alertEl.classList.add('active');
        }
        
        function closeCustomAlert() {
            document.getElementById('customAlert').classList.remove('active');
        }

        function loadModel(modelFile) {
            console.log(`Loading model: ${modelFile}`);
            
            // COMPLETE cleanup of previous model
            if (model) {
                console.log("Disposing previous model...");
                try {
                    model.getChildMeshes().forEach(mesh => {
                        if (mesh.material) {
                            mesh.material.dispose();
                        }
                        mesh.dispose();
                    });
                    model.dispose();
                } catch (e) {
                    console.error("Error disposing model:", e);
                }
                model = null;
            }
            
            // Stop all animations
            if (currentAnimGroup) {
                currentAnimGroup.stop();
                currentAnimGroup = null;
            }
            
            // Clear animation groups
            scene.animationGroups.forEach(ag => ag.dispose());
            
            animations = {};
            
            BABYLON.SceneLoader.ImportMesh("", "", modelFile, scene, 
                (meshes, particleSystems, skeletons, animationGroups) => {
                    console.log(`Model loaded: ${modelFile}`);
                    model = meshes[0];
                    
                    // Fix materials
                    model.getChildMeshes().forEach(mesh => {
                        if (mesh.material) {
                            const mat = mesh.material;
                            if (mat.getClassName() === "PBRMaterial") {
                                if (mat.albedoTexture) {
                                    if (mat.albedoTexture.hasAlpha) {
                                        mat.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_ALPHATEST;
                                        mat.alphaCutOff = 0.5;
                                        mat.useAlphaFromAlbedoTexture = true;
                                    } else {
                                        mat.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_OPAQUE;
                                        mat.useAlphaFromAlbedoTexture = false;
                                    }
                                }
                                if (!mat.metallicTexture) {
                                    mat.metallic = 0;
                                    mat.roughness = 1.0;
                                }
                                mat.backFaceCulling = true;
                                mat.twoSidedLighting = false;
                            }
                        }
                    });
                    
                    // Position model
                    const bounds = model.getHierarchyBoundingVectors();
                    const size = bounds.max.subtract(bounds.min);
                    const scale = 3 / Math.max(size.x, size.y, size.z);
                    model.scaling.setAll(scale);
                    model.computeWorldMatrix(true);
                    
                    const newBounds = model.getHierarchyBoundingVectors();
                    const center = BABYLON.Vector3.Center(newBounds.min, newBounds.max);
                    model.position = new BABYLON.Vector3(-center.x, -newBounds.min.y, -center.z);
                    
                    // Setup animations
                    animationGroups.forEach(ag => {
                        const name = ag.name.split('|')[1] || ag.name;
                        animations[name.toLowerCase()] = ag;
                    });
                    
                    createAnimationButtons();
                    if (Object.keys(animations).length > 0) {
                        playAnimation(Object.keys(animations)[0]);
                    }
                },
                null,
                (scene, msg) => console.error("Load error:", msg)
            );
        }

        function createAnimationButtons() {
            const container = document.getElementById('animButtons');
            if (!container) return; // Element doesn't exist anymore
            
            container.innerHTML = '';
            
            if (Object.keys(animations).length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">No animations</p>';
                return;
            }
            
            Object.keys(animations).forEach(name => {
                const btn = document.createElement('button');
                btn.className = 'anim-btn';
                btn.setAttribute('data-animation', name);
                btn.onclick = () => playAnimation(name);
                btn.innerHTML = `
                    <span class="btn-icon">ðŸŽ¬</span>
                    <span class="btn-label">${name.charAt(0).toUpperCase() + name.slice(1)}</span>
                `;
                container.appendChild(btn);
            });
        }

        function playAnimation(name) {
            if (!animations[name]) return;
            if (currentAnimGroup) currentAnimGroup.stop();
            animations[name].start(true);
            currentAnimGroup = animations[name];
        }

        function handleLogout() {
            if (isFirebaseConfigured && auth) {
                auth.signOut().then(() => window.location.href = 'index.html');
            } else {
                window.location.href = 'index.html';
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        if (isFirebaseConfigured) {
            // Firebase mode - wait for auth state
            auth.onAuthStateChanged(user => {
                if (user) {
                    currentUser = user;
                    document.getElementById('userGreeting').textContent = `Welcome, ${user.displayName || user.email}!`;
                    console.log("ðŸ‘¤ User authenticated:", user.email);
                    loadPetData();
                } else {
                    console.log("âŒ No user authenticated, redirecting to login");
                    window.location.href = 'index.html';
                }
            });
        } else {
            // Development mode - no auth required
            console.log("ðŸ”§ DEVELOPMENT MODE - No authentication required");
            document.getElementById('userGreeting').textContent = 'Development Mode';
            currentUser = { uid: 'dev-user' }; // Fake user for dev mode
            loadPetData();
        }

        scene = createScene();
        engine.runRenderLoop(() => scene.render());
        window.addEventListener('resize', () => engine.resize());
        
        // Start dynamic scenario system (20-60 min intervals)
        checkForScenario();
    </script>
    
    <!-- Loading Script -->
    <script src="loading.js"></script>
</body>
</html>